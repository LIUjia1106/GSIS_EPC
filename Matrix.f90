MODULE MATRICES
USE GLOBAL_VARIABLE
USE SPATIAL_GRID
USE VELOCITY_GRID
IMPLICIT NONE

REAL (KIND=DBL), ALLOCATABLE, DIMENSION (:,:), SAVE :: Ae_SOL, Ap_SOL !(NDOF_TRI,NDOF_TRI)
REAL (KIND=DBL), ALLOCATABLE, DIMENSION (:), SAVE :: Ae_SRC, Ap_SRC, FWe, FWp
INTEGER, ALLOCATABLE, DIMENSION(:), SAVE :: IPIV

INTEGER, ALLOCATABLE, DIMENSION(:,:,:), SAVE :: TRI_ORDER


CONTAINS

SUBROUTINE Init_Triangle_Order ()
IMPLICIT NONE
INTEGER :: J1,J2,I,IL,INX1,INX2,TRID1,TRID2,FCID,NUM
REAL (KIND=DBL) :: nx,ny,flux
LOGICAL :: OUTGOING
INTEGER, ALLOCATABLE, DIMENSION(:,:) :: TRI_NEIGHBOUR,TRI_IOFLAG
LOGICAL, ALLOCATABLE, DIMENSION(:) :: INARRAY


ALLOCATE (TRI_ORDER(N_TRIS,NPOLE,NAZIM))
TRI_ORDER = 0

ALLOCATE (TRI_NEIGHBOUR(N_TRIS,3))
ALLOCATE (TRI_IOFLAG(N_TRIS,3),INARRAY(N_TRIS))
TRI_NEIGHBOUR = 0
DO I = 1, N_TRIS
	DO IL = 1, 3
		FCID = TRIANGLES_TAG(I,3+IL)
		TRID1 = FACES_TAG(FCID,5)
		TRID2 = FACES_TAG(FCID,6)

		IF (I.EQ.TRID1) TRI_NEIGHBOUR(I,IL) = TRID2
		IF (I.EQ.TRID2) TRI_NEIGHBOUR(I,IL) = TRID1
	END DO
END DO

DO J2 = 1, NAZIM
	DO J1 = 1, NPOLE
		!initial IOFLAG 
		TRI_IOFLAG = 0
		DO I = 1, N_TRIS
			DO IL = 1, 3
				IF (TRI_NEIGHBOUR(I,IL).NE.0) THEN
					nx = TRIANGLES_INF(I,2*IL)
					ny = TRIANGLES_INF(I,2*IL+1)
					flux = CX(J1,J2)*nx + CY(J1,J2)*ny
					IF (flux.GT.0.d0) TRI_IOFLAG(I,IL) = 1 !outgoing
					IF (flux.LT.0.d0) TRI_IOFLAG(I,IL) = -1 !ingoing
				END IF
			END DO
		END DO
		INARRAY = .TRUE.

		NUM = 0
		DO 
			DO I = 1, N_TRIS
				IF (INARRAY(I)) THEN
					OUTGOING = .TRUE.
					DO IL = 1, 3
						IF (TRI_IOFLAG(I,IL).EQ.-1) THEN
							OUTGOING = .FALSE.
							EXIT
						END IF
					END DO
					IF (OUTGOING) THEN
						NUM = NUM + 1
						TRI_ORDER(NUM,J1,J2) = I !PUT I in the order list
						INARRAY(I) = .FALSE. !remove I in the current list
						!set neibourgh's corresponding flag as 0
						DO IL = 1, 3
							TRID2 = TRI_NEIGHBOUR(I,IL)
							IF (TRID2.NE.0) THEN
								DO INX1 = 1, 3
									IF (TRI_NEIGHBOUR(TRID2,INX1).EQ.I) THEN
										TRI_IOFLAG(TRID2,INX1) = 0
										EXIT
									END IF
								END DO
							END IF
						END DO
					END IF
				END IF
			END DO

			IF (NUM.EQ.N_TRIS) EXIT
		END DO
	END DO
END DO

!check
DO J2 = 1, NAZIM
	DO J1 = 1, NPOLE
		!WRITE(*,101)TRI_ORDER(:,J1,J2)
		!101 FORMAT (1X, 8I5)
		!IF (TRI_ORDER(1,J1,J2).EQ.419) WRITE(*,*)J1,J2
		DO I = 1, N_TRIS
			INX1 = 0
			DO IL = 1, N_TRIS
				IF (TRI_ORDER(IL,J1,J2).EQ.I) THEN
					INX1 = IL
					EXIT
				END IF
			END DO

			DO NUM = 1,3
				nx = TRIANGLES_INF(I,2*NUM)
				ny = TRIANGLES_INF(I,2*NUM+1)
				flux = CX(J1,J2)*nx + CY(J1,J2)*ny

				!FCID = TRIANGLES_TAG(I,3+NUM)
				!IF (FACES_TAG(FCID,5).EQ.I) TRID2 = FACES_TAG(FCID,6)
				!IF (FACES_TAG(FCID,6).EQ.I) TRID2 = FACES_TAG(FCID,5)
				TRID2 = TRI_NEIGHBOUR(I,NUM)

				IF (TRID2.NE.0) THEN
					INX2 = 0
					DO IL = 1, N_TRIS
						IF (TRI_ORDER(IL,J1,J2).EQ.TRID2) THEN
							INX2 = IL
							EXIT
						END IF
					END DO
					IF (flux.GT.0) THEN
						IF (INX2.LT.INX1) THEN
							WRITE(*,102)'Order Err: ', J1,J2, I, TRID2
							102 FORMAT (1X, A12, 4I5)
							STOP
						END IF
					END IF

					IF (flux.LT.0) THEN
						IF (INX2.GT.INX1) THEN
							WRITE(*,102)'Order Err: ', J1, J2, I, TRID2
							STOP
						END IF
					END IF

				END IF
			END DO
		END DO
	END DO
END DO

WRITE(*,*)'Sorting completed'


DEALLOCATE (TRI_NEIGHBOUR,TRI_IOFLAG,INARRAY)

ALLOCATE (IPIV(NDOF_TRI),Ae_SOL(NDOF_TRI,NDOF_TRI),Ap_SOL(NDOF_TRI,NDOF_TRI))
ALLOCATE (Ae_SRC(NDOF_TRI),Ap_SRC(NDOF_TRI),FWe(NDOF_TRI),FWp(NDOF_TRI))

END SUBROUTINE

END MODULE